{
  "language": "Solidity",
  "sources": {
    "Contracts/DeploymentManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\ninterface IDeploymentAccount {\r\n    function nonce() external view returns (uint128);\r\n    function callNonce() external view returns (uint128);\r\n    function create(bytes memory bytecode) external returns (address);\r\n    function create2(uint salt, bytes memory bytecode) external returns (address);\r\n    function call(address addr, uint256 amount, bytes calldata data) external;\r\n    function delegate(address addr, bytes calldata data) external;\r\n    function nop() external;\r\n}\r\n\r\ncontract DeploymentManagerStorage {\r\n    // proxy storage\r\n    uint internal _version;\r\n    address internal _manager;\r\n    address internal _implementation;\r\n\r\n    // manager storage\r\n    mapping(bytes32 => address) internal _deploymentAccounts;\r\n}\r\n\r\ncontract DeploymentManager is DeploymentManagerStorage {\r\n    \r\n    function version() public pure returns (uint) {\r\n        return 1;\r\n    }\r\n\r\n    function checkVersion(uint minver) public pure {\r\n        require(version() >= minver, \"version lower\");\r\n    }\r\n\r\n    function _ensureDeploymentAccount(address account, uint account_salt) internal returns (address) {\r\n        bytes32 deployerKey = keccak256(abi.encodePacked(account, account_salt));\r\n        address deployerAddr = _deploymentAccounts[deployerKey];\r\n        if(deployerAddr == address(0)) {\r\n            deployerAddr = _createDeploymentAccount(account, deployerKey);\r\n            require(deployerAddr != address(0), \"could not create deployer\");\r\n\r\n            _deploymentAccounts[deployerKey] = deployerAddr;\r\n        }\r\n        return deployerAddr;\r\n    }\r\n    \r\n    function _createDeploymentAccount(address account, bytes32 _salt) internal returns (address) {\r\n        return address(new DeploymentAccount{salt: _salt}(account));\r\n    }\r\n\r\n    function getDeployer(address account, uint account_salt) public view returns (address) {\r\n        bytes32 deployerKey = keccak256(abi.encodePacked(account, account_salt));\r\n        return _deploymentAccounts[deployerKey];\r\n    }\r\n\r\n    function createDeployer(address account, uint account_salt) public returns (address) {\r\n        return _ensureDeploymentAccount(account, account_salt);\r\n    }\r\n\r\n    function getDeployerAddress(address account, uint account_salt) public view returns (address) {\r\n        bytes32 deployerKey = keccak256(abi.encodePacked(account, account_salt));\r\n        bytes memory bytecode = type(DeploymentAccount).creationCode;\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(\r\n                bytes1(0xff), address(this), deployerKey, keccak256(abi.encodePacked(bytecode, abi.encode(account)))\r\n            )\r\n        );\r\n        return address (uint160(uint(hash)));\r\n    }\r\n\r\n    function getCreateAddress(address account, uint account_salt, uint nonce) public view returns (address) {\r\n        address deployer = getDeployerAddress(account, account_salt);\r\n        bytes memory data;\r\n        if (nonce == 0x00)          data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80));\r\n        else if (nonce <= 0x7f)     data = abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce));\r\n        else if (nonce <= 0xff)     data = abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce));\r\n        else if (nonce <= 0xffff)   data = abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce));\r\n        else if (nonce <= 0xffffff) data = abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce));\r\n        else                         data = abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce));\r\n        return address(uint160(uint256(keccak256(data))));\r\n    }\r\n\r\n    function getCreate2Address(address account, uint account_salt, uint salt, bytes memory bytecode) public view returns (address) {\r\n        address deployer = getDeployerAddress(account, account_salt);\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(\r\n                bytes1(0xff), deployer, salt, keccak256(bytecode)\r\n            )\r\n        );\r\n        return address (uint160(uint(hash)));\r\n    }\r\n\r\n    function create(uint account_salt, bytes memory bytecode) public returns (address) {\r\n        IDeploymentAccount deployer = IDeploymentAccount(_ensureDeploymentAccount(msg.sender, account_salt));\r\n        return deployer.create(bytecode);\r\n    }\r\n\r\n    function create2(uint account_salt, uint salt, bytes memory bytecode) public returns (address) {\r\n        IDeploymentAccount deployer = IDeploymentAccount(_ensureDeploymentAccount(msg.sender, account_salt));\r\n        return deployer.create2(salt, bytecode);\r\n    }\r\n\r\n    function call(uint account_salt, address addr, uint256 amount, bytes calldata data) public {\r\n        IDeploymentAccount deployer = IDeploymentAccount(_ensureDeploymentAccount(msg.sender, account_salt));\r\n        return deployer.call(addr, amount, data);\r\n    }\r\n\r\n    function delegate(uint account_salt, address addr, bytes calldata data) public {\r\n        IDeploymentAccount deployer = IDeploymentAccount(_ensureDeploymentAccount(msg.sender, account_salt));\r\n        return deployer.delegate(addr, data);\r\n    }\r\n\r\n    function nop(uint account_salt) public {\r\n        IDeploymentAccount deployer = IDeploymentAccount(_ensureDeploymentAccount(msg.sender, account_salt));\r\n        return deployer.nop();\r\n    }\r\n\r\n    function recoverSigner(\r\n        bytes32 _ethSignedMessageHash,\r\n        bytes memory _signature\r\n    ) internal pure returns (address) {\r\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\r\n        return ecrecover(_ethSignedMessageHash, v, r, s);\r\n    }\r\n\r\n    function splitSignature(\r\n        bytes memory sig\r\n    ) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\r\n        require(sig.length == 65, \"invalid signature length\");\r\n        assembly {\r\n            /*\r\n            First 32 bytes stores the length of the signature\r\n\r\n            add(sig, 32) = pointer of sig + 32\r\n            effectively, skips first 32 bytes of signature\r\n\r\n            mload(p) loads next 32 bytes starting at the memory address p into memory\r\n            */\r\n\r\n            // first 32 bytes, after the length prefix\r\n            r := mload(add(sig, 32))\r\n            // second 32 bytes\r\n            s := mload(add(sig, 64))\r\n            // final byte (first byte of the next 32 bytes)\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        // implicitly return (r, s, v)\r\n    }\r\n\r\n    function getEthSignatureHash(bytes32 messageHash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash));\r\n    }\r\n\r\n\r\n    function createFor(address account, uint account_salt, bytes memory bytecode, uint128 callNonce, bytes memory signature) public returns (address) {\r\n        bytes32 messageHash = getCreateHash(account, account_salt, bytecode, callNonce);\r\n        require(recoverSigner(getEthSignatureHash(messageHash), signature) == account, \"invalid signature\");\r\n\r\n        IDeploymentAccount deployer = IDeploymentAccount(_ensureDeploymentAccount(account, account_salt));\r\n        require(deployer.callNonce() == callNonce, \"nonce missmatch\");\r\n\r\n        return deployer.create(bytecode);\r\n    }\r\n\r\n    function create2For(address account, uint account_salt, uint salt, bytes memory bytecode, uint128 callNonce, bytes memory signature) public returns (address) {\r\n        bytes32 messageHash = getCreate2Hash(account, account_salt, salt, bytecode, callNonce);\r\n        require(recoverSigner(getEthSignatureHash(messageHash), signature) == account, \"invalid signature\");\r\n\r\n        IDeploymentAccount deployer = IDeploymentAccount(_ensureDeploymentAccount(account, account_salt));\r\n        require(deployer.callNonce() == callNonce, \"nonce missmatch\");\r\n\r\n        return deployer.create2(salt, bytecode);\r\n    }\r\n\r\n    function callFor(address account, uint account_salt, address addr, uint256 amount, bytes memory data, uint128 callNonce, bytes memory signature) public {\r\n        bytes32 messageHash = getCallHash(account, account_salt, addr, amount, data, callNonce);\r\n        require(recoverSigner(getEthSignatureHash(messageHash), signature) == account, \"invalid signature\");\r\n\r\n        IDeploymentAccount deployer = IDeploymentAccount(_ensureDeploymentAccount(account, account_salt));\r\n        require(deployer.callNonce() == callNonce, \"nonce missmatch\");\r\n\r\n        deployer.call(addr, amount, data);\r\n    }\r\n\r\n    function delegateFor(address account, uint account_salt, address addr, bytes memory data, uint128 callNonce, bytes memory signature) public {\r\n        bytes32 messageHash = getDelegateHash(account, account_salt, addr, data, callNonce);\r\n        require(recoverSigner(getEthSignatureHash(messageHash), signature) == account, \"invalid signature\");\r\n\r\n        IDeploymentAccount deployer = IDeploymentAccount(_ensureDeploymentAccount(account, account_salt));\r\n        require(deployer.callNonce() == callNonce, \"nonce missmatch\");\r\n\r\n        deployer.delegate(addr, data);\r\n    }\r\n\r\n    function nopFor(address account, uint account_salt, uint128 callNonce, bytes memory signature) public {\r\n        bytes32 messageHash = getNopHash(account, account_salt, callNonce);\r\n        require(recoverSigner(getEthSignatureHash(messageHash), signature) == account, \"invalid signature\");\r\n\r\n        IDeploymentAccount deployer = IDeploymentAccount(_ensureDeploymentAccount(account, account_salt));\r\n        require(deployer.callNonce() == callNonce, \"nonce missmatch\");\r\n\r\n        deployer.nop();\r\n    }\r\n\r\n    function getCreateHash(address account, uint account_salt, bytes memory bytecode, uint128 nonce) public view returns(bytes32) {\r\n        return keccak256(abi.encodePacked(address(this), \":create:\", account, account_salt, nonce, bytecode));\r\n    }\r\n\r\n    function getCreate2Hash(address account, uint account_salt, uint salt, bytes memory bytecode, uint128 nonce) public view returns(bytes32) {\r\n        return keccak256(abi.encodePacked(address(this), \":create2:\", account, account_salt, nonce, salt, bytecode));\r\n    }\r\n\r\n    function getCallHash(address account, uint account_salt, address addr, uint256 amount, bytes memory data, uint128 nonce) public view returns(bytes32) {\r\n        return keccak256(abi.encodePacked(address(this), \":call:\", account, account_salt, nonce, addr, amount, data));\r\n    }\r\n\r\n    function getDelegateHash(address account, uint account_salt, address addr, bytes memory data, uint128 nonce) public view returns(bytes32) {\r\n        return keccak256(abi.encodePacked(address(this), \":delegate:\", account, account_salt, nonce, addr, data));\r\n    }\r\n\r\n    function getNopHash(address account, uint account_salt, uint128 nonce) public view returns(bytes32) {\r\n        return keccak256(abi.encodePacked(address(this), \":nop:\", account, account_salt, nonce));\r\n    }\r\n\r\n}\r\n\r\ncontract DeploymentAccount is IDeploymentAccount {\r\n    address public _owner;\r\n    address public _manager;\r\n    uint128 private _nonce;\r\n    uint128 private _callNonce;\r\n\r\n    constructor(address owner) {\r\n        _owner = owner;\r\n        _manager = msg.sender;\r\n        _nonce = 1;\r\n        _callNonce = 0;\r\n    }\r\n\r\n    function nonce() public view returns (uint128) {\r\n        return _nonce;\r\n    }\r\n\r\n    function callNonce() public view returns (uint128) {\r\n        return _callNonce;\r\n    }\r\n\r\n    function create(bytes memory bytecode) public returns (address) {\r\n        require(msg.sender == _owner || msg.sender == _manager, \"not owner or manager\");\r\n\r\n        _nonce++;\r\n        _callNonce++;\r\n\r\n        address addr;\r\n        assembly {\r\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\r\n\r\n            if iszero(extcodesize(addr)) {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n        require(addr != address(0), \"create failed\");\r\n        return addr;\r\n    }\r\n\r\n    function create2(uint salt, bytes memory bytecode) public returns (address) {\r\n        require(msg.sender == _owner || msg.sender == _manager, \"not owner or manager\");\r\n\r\n        _nonce++;\r\n        _callNonce++;\r\n\r\n        address addr;\r\n        assembly {\r\n            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\r\n\r\n            if iszero(extcodesize(addr)) {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n        require(addr != address(0), \"create2 failed\");\r\n        return addr;\r\n    }\r\n\r\n    function call(address addr, uint256 amount, bytes calldata data) public {\r\n        require(msg.sender == _owner || msg.sender == _manager, \"not owner or manager\");\r\n\r\n        _callNonce++;\r\n\r\n        uint balance = address(this).balance;\r\n        require(balance >= amount, \"amount exceeds wallet balance\");\r\n\r\n        (bool sent, ) = payable(addr).call{value: amount}(data);\r\n        require(sent, \"call failed\");\r\n    }\r\n\r\n    function delegate(address addr, bytes calldata data) public {\r\n        require(msg.sender == _owner || msg.sender == _manager, \"not owner or manager\");\r\n\r\n        _callNonce++;\r\n\r\n        (bool sent, ) = payable(addr).delegatecall(data);\r\n        require(sent, \"call failed\");\r\n    }\r\n\r\n    function nop() public {\r\n        require(msg.sender == _owner || msg.sender == _manager, \"not owner or manager\");\r\n\r\n        _callNonce++;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "": [
          "ast"
        ],
        "*": [
          "abi",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.legacyAssembly",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "evm.gasEstimates",
          "evm.assembly"
        ]
      }
    }
  }
}