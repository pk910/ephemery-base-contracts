{
  "language": "Solidity",
  "settings": {
    "remappings": [
      "contracts/=/contracts/",
      "@rari-capital/=/@rari-capital/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  },
  "sources": {
    "contracts/SplitWallet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ISplitMain} from './interfaces/ISplitMain.sol';\nimport {ERC20} from '@rari-capital/solmate/src/tokens/ERC20.sol';\nimport {SafeTransferLib} from '@rari-capital/solmate/src/utils/SafeTransferLib.sol';\n\n/**\n * ERRORS\n */\n\n/// @notice Unauthorized sender\nerror Unauthorized();\n\n/**\n * @title SplitWallet\n * @author 0xSplits <will@0xSplits.xyz>\n * @notice The implementation logic for `SplitProxy`.\n * @dev `SplitProxy` handles `receive()` itself to avoid the gas cost with `DELEGATECALL`.\n */\ncontract SplitWallet {\n  using SafeTransferLib for address;\n  using SafeTransferLib for ERC20;\n\n  /**\n   * EVENTS\n   */\n\n  /** @notice emitted after each successful ETH transfer to proxy\n   *  @param split Address of the split that received ETH\n   *  @param amount Amount of ETH received\n   */\n  event ReceiveETH(address indexed split, uint256 amount);\n\n  /**\n   * STORAGE\n   */\n\n  /**\n   * STORAGE - CONSTANTS & IMMUTABLES\n   */\n\n  /// @notice address of SplitMain for split distributions & EOA/SC withdrawals\n  ISplitMain public immutable splitMain;\n\n  /**\n   * MODIFIERS\n   */\n\n  /// @notice Reverts if the sender isn't SplitMain\n  modifier onlySplitMain() {\n    if (msg.sender != address(splitMain)) revert Unauthorized();\n    _;\n  }\n\n  /**\n   * CONSTRUCTOR\n   */\n\n  constructor() {\n    splitMain = ISplitMain(msg.sender);\n  }\n\n  /**\n   * FUNCTIONS - PUBLIC & EXTERNAL\n   */\n\n  /** @notice Sends amount `amount` of ETH in proxy to SplitMain\n   *  @dev payable reduces gas cost; no vulnerability to accidentally lock\n   *  ETH introduced since fn call is restricted to SplitMain\n   *  @param amount Amount to send\n   */\n  function sendETHToMain(uint256 amount) external payable onlySplitMain() {\n    address(splitMain).safeTransferETH(amount);\n  }\n\n  /** @notice Sends amount `amount` of ERC20 `token` in proxy to SplitMain\n   *  @dev payable reduces gas cost; no vulnerability to accidentally lock\n   *  ETH introduced since fn call is restricted to SplitMain\n   *  @param token Token to send\n   *  @param amount Amount to send\n   */\n  function sendERC20ToMain(ERC20 token, uint256 amount)\n    external\n    payable\n    onlySplitMain()\n  {\n    token.safeTransfer(address(splitMain), amount);\n  }\n}\n"
    },
    "/@rari-capital/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\nlibrary SafeTransferLib {\n    /*///////////////////////////////////////////////////////////////\n                            ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool callStatus;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(callStatus, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 100 because the calldata length is 4 + 32 * 3.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"APPROVE_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\n        assembly {\n            // Get how many bytes the call returned.\n            let returnDataSize := returndatasize()\n\n            // If the call reverted:\n            if iszero(callStatus) {\n                // Copy the revert message into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Revert with the same message.\n                revert(0, returnDataSize)\n            }\n\n            switch returnDataSize\n            case 32 {\n                // Copy the return data into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Set success to whether it returned true.\n                success := iszero(iszero(mload(0)))\n            }\n            case 0 {\n                // There was no return data.\n                success := 1\n            }\n            default {\n                // It returned some malformed input.\n                success := 0\n            }\n        }\n    }\n}\n"
    },
    "/@rari-capital/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                             EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "contracts/interfaces/ISplitMain.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.4;\n\nimport {ERC20} from '@rari-capital/solmate/src/tokens/ERC20.sol';\n\n/**\n * @title ISplitMain\n * @author 0xSplits <will@0xSplits.xyz>\n */\ninterface ISplitMain {\n  /**\n   * FUNCTIONS\n   */\n\n  function walletImplementation() external returns (address);\n\n  function createSplit(\n    address[] calldata accounts,\n    uint32[] calldata percentAllocations,\n    uint32 distributorFee,\n    address controller\n  ) external returns (address);\n\n  function predictImmutableSplitAddress(\n    address[] calldata accounts,\n    uint32[] calldata percentAllocations,\n    uint32 distributorFee\n  ) external view returns (address);\n\n  function updateSplit(\n    address split,\n    address[] calldata accounts,\n    uint32[] calldata percentAllocations,\n    uint32 distributorFee\n  ) external;\n\n  function transferControl(address split, address newController) external;\n\n  function cancelControlTransfer(address split) external;\n\n  function acceptControl(address split) external;\n\n  function makeSplitImmutable(address split) external;\n\n  function distributeETH(\n    address split,\n    address[] calldata accounts,\n    uint32[] calldata percentAllocations,\n    uint32 distributorFee,\n    address distributorAddress\n  ) external;\n\n  function updateAndDistributeETH(\n    address split,\n    address[] calldata accounts,\n    uint32[] calldata percentAllocations,\n    uint32 distributorFee,\n    address distributorAddress\n  ) external;\n\n  function distributeERC20(\n    address split,\n    ERC20 token,\n    address[] calldata accounts,\n    uint32[] calldata percentAllocations,\n    uint32 distributorFee,\n    address distributorAddress\n  ) external;\n\n  function updateAndDistributeERC20(\n    address split,\n    ERC20 token,\n    address[] calldata accounts,\n    uint32[] calldata percentAllocations,\n    uint32 distributorFee,\n    address distributorAddress\n  ) external;\n\n  function withdraw(\n    address account,\n    uint256 withdrawETH,\n    ERC20[] calldata tokens\n  ) external;\n\n  /**\n   * EVENTS\n   */\n\n  /** @notice emitted after each successful split creation\n   *  @param split Address of the created split\n   */\n  event CreateSplit(address indexed split);\n\n  /** @notice emitted after each successful split update\n   *  @param split Address of the updated split\n   */\n  event UpdateSplit(address indexed split);\n\n  /** @notice emitted after each initiated split control transfer\n   *  @param split Address of the split control transfer was initiated for\n   *  @param newPotentialController Address of the split's new potential controller\n   */\n  event InitiateControlTransfer(\n    address indexed split,\n    address indexed newPotentialController\n  );\n\n  /** @notice emitted after each canceled split control transfer\n   *  @param split Address of the split control transfer was canceled for\n   */\n  event CancelControlTransfer(address indexed split);\n\n  /** @notice emitted after each successful split control transfer\n   *  @param split Address of the split control was transferred for\n   *  @param previousController Address of the split's previous controller\n   *  @param newController Address of the split's new controller\n   */\n  event ControlTransfer(\n    address indexed split,\n    address indexed previousController,\n    address indexed newController\n  );\n\n  /** @notice emitted after each successful ETH balance split\n   *  @param split Address of the split that distributed its balance\n   *  @param amount Amount of ETH distributed\n   *  @param distributorAddress Address to credit distributor fee to\n   */\n  event DistributeETH(\n    address indexed split,\n    uint256 amount,\n    address indexed distributorAddress\n  );\n\n  /** @notice emitted after each successful ERC20 balance split\n   *  @param split Address of the split that distributed its balance\n   *  @param token Address of ERC20 distributed\n   *  @param amount Amount of ERC20 distributed\n   *  @param distributorAddress Address to credit distributor fee to\n   */\n  event DistributeERC20(\n    address indexed split,\n    ERC20 indexed token,\n    uint256 amount,\n    address indexed distributorAddress\n  );\n\n  /** @notice emitted after each successful withdrawal\n   *  @param account Address that funds were withdrawn to\n   *  @param ethAmount Amount of ETH withdrawn\n   *  @param tokens Addresses of ERC20s withdrawn\n   *  @param tokenAmounts Amounts of corresponding ERC20s withdrawn\n   */\n  event Withdrawal(\n    address indexed account,\n    uint256 ethAmount,\n    ERC20[] tokens,\n    uint256[] tokenAmounts\n  );\n}\n"
    }
  }
}